// Code generated by protoc-gen-go. DO NOT EDIT.
// source: peer/collection.proto

package peer

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	common "github.com/hyperledger/fabric-protos-go/common"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// CollectionType enumerates the various types of private data collections.
type CollectionType int32

const (
	CollectionType_COL_UNKNOWN   CollectionType = 0
	CollectionType_COL_PRIVATE   CollectionType = 1
	CollectionType_COL_TRANSIENT CollectionType = 2
	CollectionType_COL_OFFLEDGER CollectionType = 3
	CollectionType_COL_DCAS      CollectionType = 4
)

var CollectionType_name = map[int32]string{
	0: "COL_UNKNOWN",
	1: "COL_PRIVATE",
	2: "COL_TRANSIENT",
	3: "COL_OFFLEDGER",
	4: "COL_DCAS",
}

var CollectionType_value = map[string]int32{
	"COL_UNKNOWN":   0,
	"COL_PRIVATE":   1,
	"COL_TRANSIENT": 2,
	"COL_OFFLEDGER": 3,
	"COL_DCAS":      4,
}

func (x CollectionType) String() string {
	return proto.EnumName(CollectionType_name, int32(x))
}

func (CollectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8182e05ac5917d8, []int{0}
}

// CollectionConfigPackage represents an array of CollectionConfig
// messages; the extra struct is required because repeated oneof is
// forbidden by the protobuf syntax
type CollectionConfigPackage struct {
	Config               []*CollectionConfig `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CollectionConfigPackage) Reset()         { *m = CollectionConfigPackage{} }
func (m *CollectionConfigPackage) String() string { return proto.CompactTextString(m) }
func (*CollectionConfigPackage) ProtoMessage()    {}
func (*CollectionConfigPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8182e05ac5917d8, []int{0}
}

func (m *CollectionConfigPackage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CollectionConfigPackage.Unmarshal(m, b)
}
func (m *CollectionConfigPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CollectionConfigPackage.Marshal(b, m, deterministic)
}
func (m *CollectionConfigPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionConfigPackage.Merge(m, src)
}
func (m *CollectionConfigPackage) XXX_Size() int {
	return xxx_messageInfo_CollectionConfigPackage.Size(m)
}
func (m *CollectionConfigPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionConfigPackage.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionConfigPackage proto.InternalMessageInfo

func (m *CollectionConfigPackage) GetConfig() []*CollectionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// CollectionConfig defines the configuration of a collection object;
// it currently contains a single, static type.
// Dynamic collections are deferred.
type CollectionConfig struct {
	// Types that are valid to be assigned to Payload:
	//	*CollectionConfig_StaticCollectionConfig
	Payload              isCollectionConfig_Payload `protobuf_oneof:"payload"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CollectionConfig) Reset()         { *m = CollectionConfig{} }
func (m *CollectionConfig) String() string { return proto.CompactTextString(m) }
func (*CollectionConfig) ProtoMessage()    {}
func (*CollectionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8182e05ac5917d8, []int{1}
}

func (m *CollectionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CollectionConfig.Unmarshal(m, b)
}
func (m *CollectionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CollectionConfig.Marshal(b, m, deterministic)
}
func (m *CollectionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionConfig.Merge(m, src)
}
func (m *CollectionConfig) XXX_Size() int {
	return xxx_messageInfo_CollectionConfig.Size(m)
}
func (m *CollectionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionConfig proto.InternalMessageInfo

type isCollectionConfig_Payload interface {
	isCollectionConfig_Payload()
}

type CollectionConfig_StaticCollectionConfig struct {
	StaticCollectionConfig *StaticCollectionConfig `protobuf:"bytes,1,opt,name=static_collection_config,json=staticCollectionConfig,proto3,oneof"`
}

func (*CollectionConfig_StaticCollectionConfig) isCollectionConfig_Payload() {}

func (m *CollectionConfig) GetPayload() isCollectionConfig_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CollectionConfig) GetStaticCollectionConfig() *StaticCollectionConfig {
	if x, ok := m.GetPayload().(*CollectionConfig_StaticCollectionConfig); ok {
		return x.StaticCollectionConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CollectionConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CollectionConfig_StaticCollectionConfig)(nil),
	}
}

// StaticCollectionConfig constitutes the configuration parameters of a
// static collection object. Static collections are collections that are
// known at chaincode instantiation time, and that cannot be changed.
// Dynamic collections are deferred.
type StaticCollectionConfig struct {
	// the name of the collection inside the denoted chaincode
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// a reference to a policy residing / managed in the config block
	// to define which orgs have access to this collectionâ€™s private data
	MemberOrgsPolicy *CollectionPolicyConfig `protobuf:"bytes,2,opt,name=member_orgs_policy,json=memberOrgsPolicy,proto3" json:"member_orgs_policy,omitempty"`
	// The minimum number of peers private data will be sent to upon
	// endorsement. The endorsement would fail if dissemination to at least
	// this number of peers is not achieved.
	RequiredPeerCount int32 `protobuf:"varint,3,opt,name=required_peer_count,json=requiredPeerCount,proto3" json:"required_peer_count,omitempty"`
	// The maximum number of peers that private data will be sent to
	// upon endorsement. This number has to be bigger than required_peer_count.
	MaximumPeerCount int32 `protobuf:"varint,4,opt,name=maximum_peer_count,json=maximumPeerCount,proto3" json:"maximum_peer_count,omitempty"`
	// The number of blocks after which the collection data expires.
	// For instance if the value is set to 10, a key last modified by block number 100
	// will be purged at block number 111. A zero value is treated same as MaxUint64
	BlockToLive uint64 `protobuf:"varint,5,opt,name=block_to_live,json=blockToLive,proto3" json:"block_to_live,omitempty"`
	// The member only read access denotes whether only collection member clients
	// can read the private data (if set to true), or even non members can
	// read the data (if set to false, for example if you want to implement more granular
	// access logic in the chaincode)
	MemberOnlyRead bool `protobuf:"varint,6,opt,name=member_only_read,json=memberOnlyRead,proto3" json:"member_only_read,omitempty"`
	// The member only write access denotes whether only collection member clients
	// can write the private data (if set to true), or even non members can
	// write the data (if set to false, for example if you want to implement more granular
	// access logic in the chaincode)
	MemberOnlyWrite bool `protobuf:"varint,7,opt,name=member_only_write,json=memberOnlyWrite,proto3" json:"member_only_write,omitempty"`
	// a reference to a policy residing / managed in the config block
	// to define the endorsement policy for this collection
	EndorsementPolicy *ApplicationPolicy `protobuf:"bytes,8,opt,name=endorsement_policy,json=endorsementPolicy,proto3" json:"endorsement_policy,omitempty"`
	// The type of collection.
	Type CollectionType `protobuf:"varint,9900,opt,name=type,proto3,enum=protos.CollectionType" json:"type,omitempty"`
	// The time after which the collection data expires. For example,
	// if the value is set to "10m" then the data will be purged
	// 10 minutes after it was stored. An empty value indicates that
	// the data should never be purged.
	// The format of this string must be parseable by time.ParseDuration
	TimeToLive           string   `protobuf:"bytes,9901,opt,name=TimeToLive,proto3" json:"TimeToLive,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StaticCollectionConfig) Reset()         { *m = StaticCollectionConfig{} }
func (m *StaticCollectionConfig) String() string { return proto.CompactTextString(m) }
func (*StaticCollectionConfig) ProtoMessage()    {}
func (*StaticCollectionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8182e05ac5917d8, []int{2}
}

func (m *StaticCollectionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StaticCollectionConfig.Unmarshal(m, b)
}
func (m *StaticCollectionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StaticCollectionConfig.Marshal(b, m, deterministic)
}
func (m *StaticCollectionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticCollectionConfig.Merge(m, src)
}
func (m *StaticCollectionConfig) XXX_Size() int {
	return xxx_messageInfo_StaticCollectionConfig.Size(m)
}
func (m *StaticCollectionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticCollectionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StaticCollectionConfig proto.InternalMessageInfo

func (m *StaticCollectionConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StaticCollectionConfig) GetMemberOrgsPolicy() *CollectionPolicyConfig {
	if m != nil {
		return m.MemberOrgsPolicy
	}
	return nil
}

func (m *StaticCollectionConfig) GetRequiredPeerCount() int32 {
	if m != nil {
		return m.RequiredPeerCount
	}
	return 0
}

func (m *StaticCollectionConfig) GetMaximumPeerCount() int32 {
	if m != nil {
		return m.MaximumPeerCount
	}
	return 0
}

func (m *StaticCollectionConfig) GetBlockToLive() uint64 {
	if m != nil {
		return m.BlockToLive
	}
	return 0
}

func (m *StaticCollectionConfig) GetMemberOnlyRead() bool {
	if m != nil {
		return m.MemberOnlyRead
	}
	return false
}

func (m *StaticCollectionConfig) GetMemberOnlyWrite() bool {
	if m != nil {
		return m.MemberOnlyWrite
	}
	return false
}

func (m *StaticCollectionConfig) GetEndorsementPolicy() *ApplicationPolicy {
	if m != nil {
		return m.EndorsementPolicy
	}
	return nil
}

func (m *StaticCollectionConfig) GetType() CollectionType {
	if m != nil {
		return m.Type
	}
	return CollectionType_COL_UNKNOWN
}

func (m *StaticCollectionConfig) GetTimeToLive() string {
	if m != nil {
		return m.TimeToLive
	}
	return ""
}

// Collection policy configuration. Initially, the configuration can only
// contain a SignaturePolicy. In the future, the SignaturePolicy may be a
// more general Policy. Instead of containing the actual policy, the
// configuration may in the future contain a string reference to a policy.
type CollectionPolicyConfig struct {
	// Types that are valid to be assigned to Payload:
	//	*CollectionPolicyConfig_SignaturePolicy
	Payload              isCollectionPolicyConfig_Payload `protobuf_oneof:"payload"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *CollectionPolicyConfig) Reset()         { *m = CollectionPolicyConfig{} }
func (m *CollectionPolicyConfig) String() string { return proto.CompactTextString(m) }
func (*CollectionPolicyConfig) ProtoMessage()    {}
func (*CollectionPolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8182e05ac5917d8, []int{3}
}

func (m *CollectionPolicyConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CollectionPolicyConfig.Unmarshal(m, b)
}
func (m *CollectionPolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CollectionPolicyConfig.Marshal(b, m, deterministic)
}
func (m *CollectionPolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionPolicyConfig.Merge(m, src)
}
func (m *CollectionPolicyConfig) XXX_Size() int {
	return xxx_messageInfo_CollectionPolicyConfig.Size(m)
}
func (m *CollectionPolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionPolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionPolicyConfig proto.InternalMessageInfo

type isCollectionPolicyConfig_Payload interface {
	isCollectionPolicyConfig_Payload()
}

type CollectionPolicyConfig_SignaturePolicy struct {
	SignaturePolicy *common.SignaturePolicyEnvelope `protobuf:"bytes,1,opt,name=signature_policy,json=signaturePolicy,proto3,oneof"`
}

func (*CollectionPolicyConfig_SignaturePolicy) isCollectionPolicyConfig_Payload() {}

func (m *CollectionPolicyConfig) GetPayload() isCollectionPolicyConfig_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CollectionPolicyConfig) GetSignaturePolicy() *common.SignaturePolicyEnvelope {
	if x, ok := m.GetPayload().(*CollectionPolicyConfig_SignaturePolicy); ok {
		return x.SignaturePolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CollectionPolicyConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CollectionPolicyConfig_SignaturePolicy)(nil),
	}
}

func init() {
	proto.RegisterEnum("protos.CollectionType", CollectionType_name, CollectionType_value)
	proto.RegisterType((*CollectionConfigPackage)(nil), "protos.CollectionConfigPackage")
	proto.RegisterType((*CollectionConfig)(nil), "protos.CollectionConfig")
	proto.RegisterType((*StaticCollectionConfig)(nil), "protos.StaticCollectionConfig")
	proto.RegisterType((*CollectionPolicyConfig)(nil), "protos.CollectionPolicyConfig")
}

func init() { proto.RegisterFile("peer/collection.proto", fileDescriptor_d8182e05ac5917d8) }

var fileDescriptor_d8182e05ac5917d8 = []byte{
	// 588 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x94, 0xdf, 0x52, 0xda, 0x40,
	0x14, 0xc6, 0x8d, 0xe0, 0xbf, 0x43, 0xd5, 0xb0, 0x1d, 0x69, 0xea, 0x45, 0x65, 0xb8, 0xca, 0x58,
	0x0d, 0x1d, 0xfb, 0x04, 0x88, 0x58, 0x1d, 0x11, 0x98, 0x85, 0xd6, 0x19, 0x6f, 0x32, 0x4b, 0x38,
	0xc6, 0x1d, 0x93, 0x6c, 0xdc, 0x04, 0xdb, 0xbc, 0x53, 0xfb, 0x62, 0x7d, 0x8a, 0x4e, 0x76, 0x89,
	0x44, 0xeb, 0x15, 0xcc, 0xf7, 0xfd, 0xce, 0xc9, 0x39, 0xdf, 0x6e, 0x02, 0x7b, 0x31, 0xa2, 0x6c,
	0x7b, 0x22, 0x08, 0xd0, 0x4b, 0xb9, 0x88, 0x9c, 0x58, 0x8a, 0x54, 0x90, 0x75, 0xf5, 0x93, 0xec,
	0xef, 0x79, 0x22, 0x0c, 0x45, 0xd4, 0x8e, 0x45, 0xc0, 0x3d, 0x8e, 0x89, 0xb6, 0xf7, 0xeb, 0xaa,
	0x4a, 0x89, 0x99, 0x96, 0x5a, 0x57, 0xf0, 0xa1, 0xfb, 0xdc, 0xa5, 0x2b, 0xa2, 0x3b, 0xee, 0x8f,
	0x98, 0xf7, 0xc0, 0x7c, 0x24, 0x5f, 0x60, 0xdd, 0x53, 0x82, 0x65, 0x34, 0x2b, 0x76, 0xed, 0xc4,
	0xd2, 0x25, 0x89, 0xf3, 0xba, 0x80, 0x2e, 0xb8, 0x56, 0x06, 0xe6, 0x6b, 0x8f, 0xdc, 0x82, 0x95,
	0xa4, 0x2c, 0xe5, 0x9e, 0xbb, 0x9c, 0xd6, 0x7d, 0xee, 0x6b, 0xd8, 0xb5, 0x93, 0x4f, 0x45, 0xdf,
	0xb1, 0xe2, 0x5e, 0x77, 0xb8, 0x58, 0xa1, 0x8d, 0xe4, 0x4d, 0xe7, 0x74, 0x0b, 0x36, 0x62, 0x96,
	0x05, 0x82, 0xcd, 0x5a, 0x7f, 0x2b, 0xd0, 0x78, 0xbb, 0x9e, 0x10, 0xa8, 0x46, 0x2c, 0x44, 0xf5,
	0xb4, 0x2d, 0xaa, 0xfe, 0x93, 0x3e, 0x90, 0x10, 0xc3, 0x29, 0x4a, 0x57, 0x48, 0x3f, 0x71, 0x75,
	0x24, 0xd6, 0xea, 0xcb, 0x79, 0x96, 0x9d, 0x46, 0xca, 0x5f, 0x6c, 0x6b, 0xea, 0xca, 0xa1, 0xf4,
	0x13, 0xad, 0x13, 0x07, 0xde, 0x4b, 0x7c, 0x9c, 0x73, 0x89, 0x33, 0x37, 0x8f, 0xd8, 0xf5, 0xc4,
	0x3c, 0x4a, 0xad, 0x4a, 0xd3, 0xb0, 0xd7, 0x68, 0xbd, 0xb0, 0x46, 0x88, 0xb2, 0x9b, 0x1b, 0xe4,
	0x08, 0x48, 0xc8, 0x7e, 0xf1, 0x70, 0x1e, 0x96, 0xf1, 0xaa, 0xc2, 0xcd, 0x85, 0xb3, 0xa4, 0x5b,
	0xb0, 0x3d, 0x0d, 0x84, 0xf7, 0xe0, 0xa6, 0xc2, 0x0d, 0xf8, 0x13, 0x5a, 0x6b, 0x4d, 0xc3, 0xae,
	0xd2, 0x9a, 0x12, 0x27, 0xa2, 0xcf, 0x9f, 0x90, 0xd8, 0x60, 0x16, 0xfb, 0x44, 0x41, 0xe6, 0x4a,
	0x64, 0x33, 0x6b, 0xbd, 0x69, 0xd8, 0x9b, 0x74, 0x67, 0x31, 0x6d, 0x14, 0x64, 0x14, 0xd9, 0x8c,
	0x1c, 0x42, 0xbd, 0x4c, 0xfe, 0x94, 0x3c, 0x45, 0x6b, 0x43, 0xa1, 0xbb, 0x4b, 0xf4, 0x26, 0x97,
	0xc9, 0x05, 0x10, 0x8c, 0x66, 0x42, 0x26, 0x18, 0x62, 0x94, 0x16, 0x29, 0x6d, 0xaa, 0x94, 0x3e,
	0x16, 0x29, 0x75, 0xe2, 0x38, 0xe0, 0x1e, 0x5b, 0xc6, 0x44, 0xeb, 0xa5, 0xa2, 0x45, 0x42, 0x9f,
	0xa1, 0x9a, 0x66, 0x31, 0x5a, 0xbf, 0xaf, 0x9b, 0x86, 0xbd, 0x73, 0xd2, 0xf8, 0x3f, 0xe2, 0x49,
	0x16, 0x23, 0x55, 0x10, 0x39, 0x00, 0x98, 0xf0, 0x10, 0xf5, 0x6a, 0xd6, 0x9f, 0x6b, 0x75, 0x6e,
	0x25, 0xa9, 0xf5, 0x08, 0x8d, 0xb7, 0xcf, 0x86, 0xf4, 0xc1, 0x4c, 0xb8, 0x1f, 0xb1, 0x74, 0x2e,
	0xb1, 0x98, 0x57, 0xdf, 0xb2, 0x03, 0x47, 0xbf, 0x13, 0xce, 0xb8, 0xf0, 0x75, 0x61, 0x2f, 0x7a,
	0xc2, 0x40, 0xc4, 0x78, 0xb1, 0x42, 0x77, 0x93, 0x97, 0x56, 0xe9, 0x7e, 0x1d, 0xde, 0xc1, 0xce,
	0xcb, 0x59, 0xc9, 0x2e, 0xd4, 0xba, 0xc3, 0xbe, 0xfb, 0x7d, 0x70, 0x35, 0x18, 0xde, 0x0c, 0xcc,
	0x95, 0x42, 0x18, 0xd1, 0xcb, 0x1f, 0x9d, 0x49, 0xcf, 0x34, 0x48, 0x1d, 0xb6, 0x73, 0x61, 0x42,
	0x3b, 0x83, 0xf1, 0x65, 0x6f, 0x30, 0x31, 0x57, 0x0b, 0x69, 0x78, 0x7e, 0xde, 0xef, 0x9d, 0x7d,
	0xeb, 0x51, 0xb3, 0x42, 0xde, 0xc1, 0x66, 0x2e, 0x9d, 0x75, 0x3b, 0x63, 0xb3, 0x7a, 0x4a, 0xa1,
	0x25, 0xa4, 0xef, 0xdc, 0x67, 0x31, 0xca, 0x00, 0x67, 0x3e, 0x4a, 0xe7, 0x8e, 0x4d, 0x25, 0xf7,
	0x8a, 0xc4, 0xf2, 0x0b, 0x73, 0x7b, 0xe4, 0xf3, 0xf4, 0x7e, 0x3e, 0xcd, 0x57, 0x6a, 0x97, 0xd0,
	0xb6, 0x46, 0x8f, 0x35, 0x7a, 0xec, 0x8b, 0x76, 0x4e, 0x4f, 0xf5, 0x57, 0xe1, 0xeb, 0xbf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xa8, 0xa7, 0x6b, 0xe2, 0x35, 0x04, 0x00, 0x00,
}